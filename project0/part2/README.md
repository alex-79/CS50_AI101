Завершіть Проєкт 0. Частина 2. Цей проєкт не обов'язковий для виконання, але допоможе вам закріпити набуті знання.

Для виконання цього завдання слід використовувати Python 3.11 або старіші версії програмного забезпечення, через те, що частина матеріалів курсу була створена у 2020 році, а ще вам знадобиться взаємодіяти з кількома проєктами курсу.

### **Хрестики-нулики**

Створіть штучний інтелект, який методом мінімаксу робитиме оптимальні ходи у хрестиках-нуликах.

![](https://lh7-us.googleusercontent.com/duQeE6Vs5JJXVHsodZzsOZzKiNaMSrACRYrdQz2p1JKnPsUIC8ZwXRWdyNDyen9E2opRF4z5RMNKJJF3u0cIrG9lFhdiTFRBfD5-D0CUEhF2x4lX5R352qED0u9c_eZXOcwI1cDryeGgy2Q4OTtYmh8)

### **Як отримати допомогу**

1.  Поставте запитання на форумі курсу.
2.  Зверніться за підказкою до будь-якої спільноти [CS50](https://cs50.harvard.edu/ai/2023/communities/).

### **Початок роботи**

*   Завантажте скрипт коду з [https://cdn.cs50.net/ai/2023/x/projects/0/tictactoe.zip](https://cdn.cs50.net/ai/2023/x/projects/0/tictactoe.zip) та розархівуйте його.
*   Тільки-но потрапите до каталогу проєкту, запустіть `pip3 install -r requirements.txt`, щоб встановити необхідний пакет Python (pygame) для хрестиків-нуликів.

### **Знайомство з кодом**

Цей проєкт складається з двох файлів: **runner.py** та **tictactoe.py**. Останній допоможе зрозуміти логіку гри й вибору оптимальних ходів. Графічний інтерфейс гри міститься у **runner.py** — він вже готовий для запуску. Після того, як завершите написання коду необхідних функції в **tictactoe.py**, запустіть **python runner.py**, та зіграйте проти вашого штучного інтелекту!

Отже, відкриймо **tictactoe.py**, щоб зрозуміти, як працюватиме програма. Спочатку треба визначити три змінні: **X**, **O** та **EMPTY**, щоб відобразити можливі ходи.

Функція **initial\_state** повертатиме початковий стан ігрового поля. У цьому завданні пропонуємо визначити ігрове поле як список з трьох списків (що представляють три рядки дошки), де кожен вкладений список містить три значення — **X**, або **O**, або **EMPTY**. Нижче ви знайдете функції, які треба доповнити кодом, щоби програма запрацювала як належить.

### **Технічні вимоги**

Вам необхідно реалізувати функції **player**, **actions**, **result**, **winner**, **terminal**, **utility** та **minimax**.

*   Функція **player** повинна приймати на вхід стан дошки і повертати, якого гравця зараз хід (або X, або O).
    *   У початковому стані гри X є першим ходом. Далі з кожним наступним ходом гравець чергується.
    *   Будь-яке повернене значення є прийнятним, якщо на вхід подається завершальне поле (тобто гра вже завершилася).

*   Функція **actions** повертатиме множину (**set**) всіх можливих дій, які можна виконати на ігровому полі.
    *   Кожна дія має бути кортежем (**i, j**), де **i** відповідає рядку поточного ходу (0, 1 або 2), а **j** — комірці у цьому рядку, що відповідає поточному ходу (також 0, 1 або 2).
    *   Хід можна зробити у будь-яку комірку ігрового поля, де ще немає **X** або **O**.
    *   Будь-яке повернене значення є прийнятним, якщо на вхід подається завершальне поле.

*   Функція **result** приймає на вхід поле (**board**) та дію (**action**) і має повертати новий стан ігрового поля без зміни вхідного поля. 
    *   Якщо дія (**action**) недопустима для цього поля, ваша програма має [згенерувати виняток](https://docs.python.org/3/tutorial/errors.html#raising-exceptions).
    *   Повернуте поле повинно бути таким, яке було б отримано, якщо взяти початкове поле і дозволити гравцю, чия черга, зробити хід на клітинку, вказану вхідною дією.
    *   Параметри вхідного ігрового поля мають залишатися без змін, оскільки під час обчислення мінімаксу треба буде врахувати багато різних станів поля. Це означає, що лише оновлення комірки на ігровому полі (**board**) не дозволить функції **result** повернути правильний результат. Ймовірно, ви спочатку захочете зробити [глибоку копію](https://docs.python.org/3/library/copy.html#copy.deepcopy) ігрового поля, а вже потім вносити будь-які зміни.

*   Функція **winner** визначатиме переможця (якщо такий є) відповідно до поточного стану ігрового поля, який передається на вхід функції.
    *   Якщо гравець X виграв, функція повертатиме **X**. Так само, якщо гравець O виграв, функція повертатиме **O**.
    *   Щоб виграти гру, необхідно зібрати три хрестика або три нолика підряд по горизонталі, вертикалі або діагоналі.
    *   Може бути лише один переможець, адже за правилами два гравці не можуть одночасно зібрати виграшні комбінації (це вважатиметься недійсним станом ігрового поля).
    *   Якщо переможця немає (бо гра триває або закінчилася нічиєю), функція має повернути **None**.

*   Функція **terminal** повертатиме істинне чи хибне відповідно до поточного стану ігрового поля, тобто сповіщатиме про завершення гри. Функція приймає на вхід поточне ігрове поле (**board**).
    *   Якщо гру завершено через чиїсь виграш, або якщо всі комірки заповнено і ніхто не виграв, функція має повернути  інстинне (**True**).
    *   Відповідно, якщо гра все ще триває, то хибне (**False**).

*   Функція **utility** повинна приймати на вхід завершальне поле і має оцінити результативність (яке цільове значення досягнуто), та повернути його.
    *   Якщо гру виграв X, результат дорівнюватиме 1. Якщо виграв O, то -1. У результаті нічиєї результат дорівнюватиме 0.
    *   Вважається, що функцію **utility** можна викликати лише після завершення гри (якщо функція **terminal(board)**, своєю чергою, повернула істинне).

*   Функція **minimax** повинна приймати на вхід ігрове поле (board) і має визначити оптимальний хід гравця відповідно до поточного стану ігрового поля.
    *   Тобто повернути оптимальну дію (**i, j**), або допустимий хід для цього ігрового поля. Якщо однаково оптимальні кілька ходів, допустимим вважатиметься будь-який з них.
    *   Якщо досягнуто завершального стану дошки (гру завершено), функція має повернути **None**.

Вважається, що обробка вхідних даних в усіх функціях, відбувається на дійсному ігровому полі (**board**) (що складається з трьох рядків, кожен з яких містить X, O або EMPTY). Зауважте, що ви не повинні змінювати надані оголошення функцій (порядок або кількість аргументів для кожної функції).

Після того, як доповните усі зазначені функції, зможете запустити **python runner.py** і зіграти проти вашого штучного інтелекту. Однак, оскільки за умов найкращої гри обох противників результатом хрестиків-нуликів буде нічия, ви ніколи не зможете обіграти штучний інтелект (а от якщо ви граєте не найкраще, він може обіграти вас!).

### **Підказки**

*   Якщо ви захочете протестувати функції в іншому файлі Python, зможете імпортувати їх за допомогою коду на кшталт **from tictactoe import initial\_state.**
*   Ви можете додавати власні допоміжні функції до **tictactoe.py**, якщо їх назви відрізняються від назв функцій або змінних з наданого вище коду програми.
*   Не обов’язково застосовувати альфа-бета відсічення, проте це поліпшить роботу вашого штучного інтелекту. 

### **Тестування**

Ви можете виконати наведені нижче дії (після налаштування [check50](https://courses.prometheus.org.ua/courses/course-v1:HarvardUniversity+CS50_AI101+2023_T3/jump_to_id/f6a60e4407084acc864b80a22cdc987d) у вашій системі), щоб оцінити коректність вашого коду за бажанням. Це не є обов'язковим; ви можете просто відправити код, дотримуючись інструкцій в кінці, і ті ж самі тести будуть запущені на сервері. У будь-якому випадку, не забудьте скомпілювати і протестувати код самостійно!

`check50 ai50/projects/2024/x/tictactoe`

Виконайте наведені нижче дії, щоб оцінити стиль вашого коду за допомогою style50.

`style50 tictactoe.py`

Пам'ятайте, що ви не можете імпортувати будь-які модулі (окрім тих, що входять до стандартної бібліотеки Python), окрім тих, що явно дозволені в цьому документі. 

### **Як подати завдання**

Проєкти у цьому курсі не оцінюються, але ми закликаємо вас виконувати їх для перевірки набутих знань. 

1.  Перейдіть за [цим посиланням](https://submit.cs50.io/invites/d03c31aef1984c29b5e7b268c3a87b7b), увійдіть за допомогою свого облікового запису GitHub і натисніть  Authorize cs50. Потім встановіть прапорець, що вказує на те, що ви хочете надати доступ співробітникам курсу до ваших матеріалів, і натисніть Приєднатися до курсу (Join course).
2.  Встановіть [Git](https://git-scm.com/downloads) і, за бажанням, встановіть [submit50](https://cs50.readthedocs.io/submit50/).
3.  Якщо ви встановили submit50, виконайте

`submit50 ai50/projects/2024/x/tictactoe`

В іншому випадку, використовуючи Git, подайте свою роботу на [https://github.com/me50/USERNAME.git](https://github.com/me50/USERNAME.git),  де USERNAME - це ваше ім'я користувача GitHub, на гілку під назвою _ai50/projects/2024/x/tictactoe_

Якщо ви надсилаєте свій код безпосередньо через Git, а не через submit50, не включайте директорії **large** або **small** до вашого файлу. submit50 автоматично виключить їх для вас. Ви повинні додавати лише ті файли, які ви дійсно маєте змінити відповідно до наведених технічних вимог.